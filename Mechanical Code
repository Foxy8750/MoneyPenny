#include <AccelStepper.h>
#include <SoftwareSerial.h>
#include <U8glib.h>
#include <GCodeParser.h>
#include <SPI.h>
#include <SD.h>



//Define X Stepper Motor
const int X_STEP_PIN = 54;
const int X_DIR_PIN = 55;
const int X_ENABLE_PIN = 38;
const int X_MIN_PIN = 3;
float X_MIN;
float X_CURRENT;
const float X_MAX = 11.0; //mm
const float stepsPerMM_X = 120.0;

AccelStepper stepperX(AccelStepper::DRIVER, X_STEP_PIN, X_DIR_PIN);



//Define Y Stepper Motor
const int Y_STEP_PIN = 60;
const int Y_DIR_PIN = 61;
const int Y_ENABLE_PIN = 56;
const int Y_MIN_PIN = 14;
float Y_MIN;
float Y_CURRENT;
const float Y_MAX = 6.0; //mm
const float stepsPerMM_Y = 40.0;

AccelStepper stepperY(AccelStepper::DRIVER, Y_STEP_PIN, Y_DIR_PIN);




//Define Z Servo Motor
const int Z_SERVO_PIN = 11;



//Define LCD Display
U8GLIB_ST7920_128X64_1X u8g(23, 17, 16);



//Define Rotary Encoder and Buzzer
const int ENCODER_A_PIN = 31;
const int ENCODER_B_PIN = 33;
const int ENCODER_BTN_PIN = 35;
const int BUZZER_PIN = 37;

// Define Encoder State
int selectedIndex = 0;
bool lastEncoderA = HIGH;
bool lastButtonState = HIGH;
bool fileSelected = false;

// File listing
String fileList[20];
int fileCount = 0;



//Define SD Card Reader
const int SD_CS_PIN = 53;

// G-code reading
GCodeParser parser;
String selectedFilename = "";
File currentFile;

String gcodeBuffer[3];  // Line buffering
int bufferIndex = 0;
String lastCommand = "";

//Relative vs Absolute Mode
bool relativeMode = false;  // false = absolute mode (default)



//Define Fan
const int FAN_PIN = 9;





void setup() {
  //Open communication line with the Serial Port (i.e. my computer)
  Serial.begin(115200);



  //Initialize X Axis
  pinMode(X_ENABLE_PIN, OUTPUT);
  digitalWrite(X_ENABLE_PIN, LOW); // LOW to enable motor
  pinMode(X_DIR_PIN, OUTPUT); 
  pinMode(X_STEP_PIN, OUTPUT);
  pinMode(X_MIN_PIN, INPUT);

  //Initialize Speed and Acceleration for the X Stepper
  stepperX.setMaxSpeed(100);
  stepperX.setAcceleration(50);  



  //Initialize Y Axis
  pinMode(Y_ENABLE_PIN, OUTPUT);
  digitalWrite(Y_ENABLE_PIN, LOW);
  pinMode(Y_DIR_PIN, OUTPUT);
  pinMode(Y_STEP_PIN, OUTPUT);
  pinMode(Y_MIN_PIN, INPUT);

  //Invert Stepper Y Direction
  stepperY.setPinsInverted(true, false, false);

  //Initialize Speed and Acceleration for the Y Stepper
  stepperY.setMaxSpeed(100);
  stepperY.setAcceleration(50);
  


  //Move X Stepper to Min and Set Min
  stepperX.setSpeed(-50);
  while (digitalRead(X_MIN_PIN) == HIGH) { // assumes LOW = pressed, HIGH = not pressed
    stepperX.runSpeed();
  }
  stepperX.setCurrentPosition(0.0); //MAKE SURE THAT RIGHT STOP IS IN THE POSITIVE DIRECTION!!!
  X_MIN = stepperX.currentPosition(); //WOULD BE USEFUL IF THIS SET ORIGIN
  X_CURRENT = 0.0;
  stepperX.stop();



  //Move Y Stepper to Min and Set Min
  stepperY.setSpeed(-50);
  while (digitalRead(Y_MIN_PIN) == HIGH) {
    stepperY.runSpeed();
  }
  stepperY.setCurrentPosition(0.0);
  Y_MIN = stepperY.currentPosition(); //WOULD BE USEFUL IF THIS SET ORIGIN
  Y_CURRENT = 0.0;
  stepperY.stop();



  //Move X and Y to their Max Positions
  stepperX.moveTo(Y_MAX * stepsPerMM_X);
  stepperY.moveTo(Y_MAX * stepsPerMM_Y);

  while (stepperX.distanceToGo() != 0 || stepperY.distanceToGo() != 0) {
    stepperX.run();
    stepperY.run();
  }

  X_CURRENT = X_MAX;
  Y_CURRENT = Y_MAX;



  //Initialize Rotary Encoder and Buzzer
  pinMode(ENCODER_A_PIN, INPUT_PULLUP);
  pinMode(ENCODER_B_PIN, INPUT_PULLUP);
  pinMode(ENCODER_BTN_PIN, INPUT_PULLUP);
  pinMode(BUZZER_PIN, OUTPUT);
  digitalWrite(BUZZER_PIN, LOW);

  if (!SD.begin(SD_CS_PIN)) {
    Serial.println("SD init failed");
  } else {
    Serial.println("SD init OK");
    listFiles();
  }



  //Initialize Fan
  pinMode(FAN_PIN, OUTPUT);
  analogWrite(FAN_PIN, 0); // Make sure it's off at startup
}






void listFiles() {
  File root = SD.open("/");
  fileCount = 0;

  while (true) {
    File entry = root.openNextFile();
    if (!entry) break;

    String name = entry.name();
    if (!entry.isDirectory() && (name.endsWith(".gcode") || name.endsWith(".txt"))) {
      fileList[fileCount++] = name;
      Serial.println("Found: " + name);
      if (fileCount >= 20) break;
    }
    entry.close();
  }
}






void loop() {
  if (!fileSelected) {
    handleEncoder();
    drawFileMenu();

    bool buttonState = digitalRead(ENCODER_BTN_PIN);
    if (buttonState == LOW && lastButtonState == HIGH) {
      tone(BUZZER_PIN, 1000, 100);
      selectedFilename = fileList[selectedIndex];
      currentFile = SD.open(selectedFilename);
      if (currentFile) {
        Serial.print("Opening file: ");
        Serial.println(fileList[selectedIndex]);
        fileSelected = true;
      } else {
        Serial.println("Failed to open file!");
      }
    }
    lastButtonState = buttonState;

  } else {
    readAndExecuteGcode();
  }

  delay(50);
}






void handleEncoder() {
  bool A = digitalRead(ENCODER_A_PIN);
  bool B = digitalRead(ENCODER_B_PIN);

  if (A != lastEncoderA && A == LOW) {
    if (B == HIGH) selectedIndex++;
    else selectedIndex--;

    if (selectedIndex < 0) selectedIndex = 0;
    if (selectedIndex >= fileCount) selectedIndex = fileCount - 1;
  }
  lastEncoderA = A;
}






void drawFileMenu() {
  u8g.firstPage();
  do {
    u8g.setFont(u8g_font_6x10);
    for (int i = 0; i < min(fileCount, 6); i++) {
      int displayIndex = selectedIndex >= 6 ? selectedIndex - 5 + i : i;
      if (displayIndex >= fileCount) break;

      if (displayIndex == selectedIndex) {
        u8g.drawBox(0, i * 10, 128, 10);
        u8g.setColorIndex(0);
      } else {
        u8g.setColorIndex(1);
      }

      u8g.setPrintPos(2, (i + 1) * 10 - 2);
      u8g.print(fileList[displayIndex]);
    }
    u8g.setColorIndex(1);
  } while (u8g.nextPage());
}







void readAndExecuteGcode() {
  analogWrite(FAN_PIN, 255);  // Turn fan on full speed at start
  
  File file = SD.open(selectedFilename);
  if (!file) {
    Serial.println("Failed to open file");
    return;
  }

  while (file.available()) {
    String line = file.readStringUntil('\n');
    line.trim();
    if (line.length() == 0 || line.startsWith(";")) continue;  // Skip comments

    parser.ParseLine(line.c_str());  // Parse the line

    String cmd = "";
    if (parser.HasWord('G')) {
      cmd = "G" + String((int)parser.GetWordValue('G'));
    } else if (parser.HasWord('M')) {
      cmd = "M" + String((int)parser.GetWordValue('M'));
    }
    drawGcodeStatusScreen(cmd);

    // Handle positioning mode
    if (cmd == "G90") {
      relativeMode = false;
      continue;
    } else if (cmd == "G91") {
      relativeMode = true;
      continue;
    }

    // Example: G1 linear move
    if (cmd == "G1") {
      float targetX = X_CURRENT;
      float targetY = Y_CURRENT;

      if (parser.HasWord('X')) {
        float xVal = parser.GetWordValue('X');
        targetX = relativeMode ? X_CURRENT + xVal : xVal;

      // Clamp to bounds
      if (targetX > X_MAX) targetX = X_MAX;
      if (targetX < X_MIN) targetX = X_MIN;
      }

      if (parser.HasWord('Y')) {
        float yVal = parser.GetWordValue('Y');
        targetY = relativeMode ? Y_CURRENT + yVal : yVal;

        // Clamp to bounds
      if (targetY > Y_MAX) targetY = Y_MAX;
      if (targetY < Y_MIN) targetY = Y_MIN;
      }

      // Move the motors
      stepperX.moveTo(targetX * stepsPerMM_X);
      stepperY.moveTo(targetY * stepsPerMM_Y);

      while (stepperX.distanceToGo() != 0 || stepperY.distanceToGo() != 0) {
        stepperX.run();
        stepperY.run();
      }

      X_CURRENT = targetX;
      Y_CURRENT = targetY;
    }

  }

  file.close();
  analogWrite(FAN_PIN, 0);
}

void drawGcodeStatusScreen(String lastCommand) {
  u8g.firstPage();
  do {
    u8g.setFont(u8g_font_6x10);
    u8g.drawStr(5, 15, "Reading G-code...");
    u8g.drawStr(5, 30, fileList[selectedIndex].c_str());

    u8g.setPrintPos(5, 50);
    u8g.print("Cmd: ");
    u8g.print(lastCommand);
  } while (u8g.nextPage());
}